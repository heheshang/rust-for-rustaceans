# 第三章 设计接口

每个项目，无论大小，都有一个 API。事实上，它通常有几个。其中有些是面向用户的，比如 HTTP 端点或命令行接口，有些是面向开发者的，比如一个库的公共接口。在这些之上，Rust crates 还有一些内部接口：每个类型、特质和模块边界都有自己的微型 API，你的其他代码与之接口。随着你的代码库的规模和复杂性的增加，你会发现值得在如何设计内部 API 上投入一些心思和精力，以使使用和维护代码的经验尽可能的愉快。

在这一章中，我们将探讨在 Rust 中编写惯用接口的一些最重要的考虑因素，无论这些接口的用户是你自己的代码还是其他使用你的库的开发者。这基本上可以归结为四个原则：你的接口应该是意料中的 (unsurprising)，灵活的 (flexible)，明显的 (obvious)，以及受约束的 (constrained)。我将依次讨论这些原则，以便为编写可靠和可用的接口提供一些指导。

我强烈建议你在读完本章后看看 Rust API 指南（`https://rust-lang.github.io/api-guidelines/`）。那里有一个很好的检查表，你可以按照它来做，并对每个建议进行了详细的梳理。本章中的许多建议也是由 `cargo clippy` 工具检查的，如果你还没有开始在你的代码上运行，你应该开始运行这个工具。我还鼓励你阅读 RFC 1105（`https://rust-lang.github.io/rfcs/1105-api-evolution.html`）和 `The Cargo Book` 中关于 SemVer 兼容性的章节（`https://doc.rust-lang.org/cargo/reference/semver.html`），这些章节涵盖了 Rust 中什么是和什么不是破坏性变化。

## 意料中的（Unsurprising）

最小惊奇原则，又称最小惊奇法则，在软件工程中经常出现，它对 Rust 接口也是如此。在可能的情况下，你的接口应该足够直观，如果用户需要猜测，他们通常会猜对。当然，并不是所有关于你的应用程序的东西都会立即变得直观，但任何不令人惊讶的东西都应该是直观的。这里的核心思想是紧贴用户可能已经知道的东西，这样他们就不必以不同于他们习惯的方式重新学习概念。这样一来，你就可以把他们的脑力节省下来，去弄清楚那些真正与你的接口有关的东西。

有很多方法可以让你的接口变得可预测。在这里，我们将看看你如何利用命名、共同特征和人体工程学特征的技巧来帮助用户解决问题。

### 命名惯例

用户在使用你的接口时，首先会通过它的名字来了解它；他们会立即开始从他们遇到的类型、方法、变量、字段和库的名称中推断出一些东西。如果你的接口重用了其他（也许是常见的）接口的名称--比如说，方法和类型，用户就会知道他们可以对你的方法和类型做出某些假设。一个叫做 `iter` 的方法可能需要 `&self`，并且可能给你一个迭代器。一个叫做 `into_inner` 的方法可能会接收 `self`，并且可能会返回某种包装好的类型。一个叫做 `SomethingError` 的类型可能实现了 `std::error::Error`，并出现在各种 `Result` 中。通过重复使用相同目的的通用名称，你让用户更容易猜到事情的作用，并让他们更容易理解你的接口的不同之处。

这方面的一个推论是，共用一个名字的东西实际上应该以同样的方式工作。否则--例如，如果你的 `iter` 方法接受 `&self`，或者如果你的 `SomethingError` 类型没有实现 `Error`--用户很可能会根据他们期望的接口工作方式写出错误的代码。他们会感到惊讶和沮丧，并不得不花时间去研究你的接口与他们的期望有什么不同。当我们可以为用户节省这种摩擦时，我们应该做。

### 类型的共同 traits

Rust 中的用户也会做出一个主要的假设，即接口中的一切都 "只是在工作"。他们期望能够用 `{:?}` 打印任何类型，并将任何东西发送到另一个线程，他们还期望每个类型都是 `Clone`。在可能的情况下，我们应该再次避免让用户感到惊讶，并急切地实现大多数标准特性，即使我们并不立即需要它们。

由于第二章中讨论的一致性规则，编译器将不允许用户在需要时实现这些特质。用户不允许为一个外来的类型（如 `Clone`）实现一个外来的特性，如你的接口中的一个。他们需要将你的接口类型包裹在他们自己的类型中，如果不接触该类型的内部结构，要写出一个合理的实现可能会相当困难。

在这些标准特性中，首先是 `Debug` 特性。几乎每个类型都可以，而且应该实现 `Debug`，即使它只打印类型的名称。使用`#[derive(Debug)]` 通常是在你的接口中实现 `Debug trait` 的最好方法，但请记住，所有派生 trait 都会自动为任何泛型参数添加相同的绑定。 你也可以简单地通过利用 `fmt::Formatter` 上的各种 `debug_` 助手来编写自己的实现。

并列第二的是 Rust 的自动特性 `Send` 和 `Sync`（以及在较小的程度上，`Unpin`）。如果一个类型没有实现这些特性之一，应该是有很好的理由的。不是 `Send` 的类型不能被放在 `Mutex` 中，甚至不能在包含线程池的应用程序中过渡使用。不是同步的类型不能通过 `Arc` 共享或放在静态变量中。用户已经开始期望类型能在这些情况下工作，特别是在几乎所有东西都在线程池上运行的异步世界中，如果你不确保你的类型实现这些特性，他们会感到沮丧。如果你的类型不能实现这些特性，请确保这个事实和原因都被很好地记录下来。

你应该实现的下一组几乎通用的特性是 `Clone` 和 `Default`。这些特性可以很容易地被派生或实现，对大多数类型来说，实现这些特性是有意义的。如果你的类型不能实现这些特性，请确保在你的文档中指出来，因为用户通常期望能够轻松地创建更多（和新）类型的实例，因为他们认为合适。如果他们不能，他们会感到惊讶。

在预期特质的层次结构中再往下一步就是比较特质。`PartialEq`, `PartialOrd`, `Hash`, `Eq`, 和 `Ord`。`PartialEq` 特质是特别可取的，因为用户在某些时候不可避免地会有两个你的类型的实例，他们希望用 `==` 或 `assert_eq` 来比较！。即使你的类型只对同一类型的实例进行等价比较，也值得实现 `PartialEq` 以使你的用户能够使用 `assert_eq`！

`PartialOrd` 和 `Hash` 更为专业，可能适用范围不那么广，但在可能的情况下，你也要实现它们。 这对于用户可能用作地图中的键的类型，或者他们可能使用任何 `std::collection` 集合类型来重复的类型尤其如此，因为它们往往需要这些边界。除了 `PartialEq` 和 `PartialOrd` 之外，`Eq` 和 `Ord` 还对实现类型的比较操作有额外的语义要求。这些在这些特性的文档中都有很好的记录，只有当你确定这些语义确实适用于你的类型时，你才应该实现它们。

最后，对于大多数类型来说，实现 `serde` 包的 `Serialize` 和 `Deserialize` 特性是有意义的。这些都可以很容易地派生出来，而且 `serde_derive` 包甚至有机制可以重写一个字段或枚举变体的序列化。由于 `serde` 是一个第三方板块，你可能不希望添加对它的必要依赖。因此，大多数库选择提供一个 `serde` 特性，只有在用户选择时才增加对 `serde` 的支持。

你可能想知道为什么我没有把可派生特质 `Copy` 列入本节。有两件事使 `Copy` 与其他提到的特质不同。第一件事是，用户一般不期望类型是 `Copy`；恰恰相反，他们倾向于期望，如果他们想要某个东西的两个副本，他们必须调用 `clone`。复制改变了移动给定类型的值的语义，这可能会让用户感到惊讶。这与第二个观察相联系：一个类型很容易不再是 `Copy`，因为 `Copy` 类型受到高度限制。一个开始很简单的类型很容易最终不得不容纳一个字符串，或者其他一些非拷贝类型。如果发生这种情况，你不得不删除 `Copy` 的实现，这就是一个向后不兼容的变化。相比之下，你很少需要删除 `Clone` 的实现，所以这是个不太沉重的承诺。

### 人体工程学特质的实现 (Ergonomic Trait Implementations)

Rust 不会自动为对实现特质的类型的引用实现特质。换个说法，你一般不能用 `&Bar` 调用 `fn foo<T: Trait>(t: T)`，即使 `Bar:Trait`。这是因为 `Trait` 可能包含了采取 `&mut self` 或 `self` 的方法，这显然不能在 `&Bar` 上调用。尽管如此，这种行为可能会让看到 `Trait` 只有 `&self` 方法的用户感到非常惊讶。

出于这个原因，当你定义一个新的特性时，你通常会想为该特性提供适当的覆盖实现，如 `&T where T: Trait, &mut T where T: Trait`，以及 `&T where T: Trait, &mut T where T: Trait`。你可能只能实现其中的一部分，这取决于 `Trait` 的方法有哪些接收者。标准库中的许多特质都有类似的实现，正是因为这样可以减少用户的意外。

迭代器是另一种情况，在这种情况下，你经常想在对一个类型的引用上特别添加特质实现。对于任何可以被迭代的类型，考虑为 `&MyType` 和 `&mut MyType` 实现 `IntoIterator`。这使得循环在你的类型的借用实例上也能开箱即用，就像用户所期望的那样。

### 包装类型

Rust 没有经典意义上的对象继承。 然而，`Deref trait` 和它的表亲 `AsRef` 都提供了类似于继承的东西。这些特征允许你拥有一个 `T` 类型的值，并通过直接在 `T` 类型的值上调用方法，如果 `T: Deref<Target = U>` 的话。这对用户来说就像魔法一样，而且一般来说是很好的。

如果你提供了一个相对透明的包装类型（如 `Arc`），你很有可能想要实现 `Deref`，这样用户就可以通过使用 `.` 操作符来调用内部类型上的方法。如果访问内部类型不需要任何复杂或潜在的缓慢逻辑，你也应该考虑实现 `AsRef`，它允许用户轻松地将 `&WrapperType` 作为 `&InnerType` 使用。对于大多数包装类型，你还想尽可能地实现 `From<InnerType>` 和 `Into<InnerType>`，这样你的用户就可以轻松地添加或删除你的包装。

你可能也遇到过 `Borrow` 特质，它感觉与 `Deref` 和 `AsRef` 非常相似，但实际上有点不同。具体来说，`Borrow` 是为一个更狭窄的用例而定制的：允许调用者提供同一类型的多个本质上相同的变体中的任何一个。也许，它可以被称为等价 (`Equivalent`)。例如，对于一个 `HashSet<String>`，`Borrow` 允许调用者提供一个 `&str` 或者一个 `&String`。虽然同样的情况可以用 `AsRef` 来实现，但如果没有 `Borrow` 的额外要求，即目标类型对 `Hash`、`Eq` 和 `Ord` 的实现与实现类型完全相同，这就不安全了。`Borrow` 还为 `T`、`&T` 和 `&mut T` 提供了一个 `Borrow<T>`的覆盖实现，这使得它在特质边界中的使用非常方便，可以接受一个给定类型的自有值或引用值。一般来说，`Borrow` 只用于你的类型本质上等同于另一个类型，而 `Deref` 和 `AsRef` 则是为了更广泛地实现你的类型可以 "作为 "的任何东西。

> DEREF 和固有方法
> 当 `T` 上有以 `self` 的方法时，围绕点运算符和 `Deref` 的魔法会变得混乱和令人惊讶。例如，给定一个值 `t`。`T`，不清楚 `t.frobnicate()` 是对 `T` 还是对底层的 `U` 进行 `frobnicate`！由于这个原因，那些允许你透明地调用一些事先不知道的内部类型的方法的类型应该避免使用固有方法。`Vec` 可以有一个 `push` 方法，即使它解除对 slice 的引用，因为你知道 slice 不会很快得到一个 `push` 方法。但是，如果您的类型取消对用户控制的类型的引用，那么您添加的任何固有方法也可能存在于该用户控制的类型上，从而导致问题。在这些情况下，倾向于 `fn frobnicate(t: t)` 形式的静态方法。这样，`t.frobnicate()` 总是调用 `U::frobnicate`，而 `t::frobnicate(t)` 可以用来 `T` 本身。

## 灵活的

你写的每一段代码都隐含地或明确地包括一个契约。契约由一组要求和一组承诺组成。要求是对代码如何被使用的限制，而承诺是对代码如何被使用的保证。当设计一个新的接口时，你要仔细考虑这个契约。一个好的经验法则是避免强加不必要的限制，只做出你能遵守的承诺。 增加限制或删除承诺通常需要一个重大的语义版本变化，并可能破坏其他地方的代码。 另一方面，放松限制或给出额外的承诺，通常是向后兼容的。

在 Rust 中，限制通常以特质约束和参数类型的形式出现，而承诺则以特质实现和返回类型的形式出现。例如，比较清单 3-1 中的三个函数签名。

```rust
fn frobnicate1(s: String) -> String
fn frobnicate2(s: &str) -> Cow<'_, str>
fn frobnicate3(s: impl AsRef<str>) -> impl AsRef<str>

// 清单 3-1：具有不同契约的类似函数签名
```

这三个函数签名都接收一个字符串并返回一个字符串，但它们是在非常不同的契约下进行的。

第一个函数要求调用者以 `String` 类型的形式拥有字符串，它承诺将返回一个拥有（所有权）的 `String`。 由于契约要求调用者分配，并要求我们返回一个拥有的字符串，我们以后不能以向后兼容的方式使这个函数免分配。

第二个函数放宽了契约：调用者可以提供任何对字符串的引用，所以用户不再需要分配或放弃对一个字符串的所有权。它还承诺返回一个 `std::borrow::Cow`，这意味着它可以返回一个字符串引用或者一个拥有的字符串，这取决于它是否需要拥有该字符串。这里的承诺是，该函数将始终返回一个 `Cow`，这意味着我们不能，比如说，以后改变它以使用其他优化的字符串表示。调用者也必须特别提供一个`&str`，所以如果他们有，比如说，他们自己的一个预先存在的 `String`，他们必须将其解除引用为一个 `&str` 来调用我们的函数。

第三个函数取消了这些限制。它只要求用户传入可以生成字符串引用的类型，并且只承诺返回值可以生成字符串引用。

这些函数签名中没有一个比其他的更好。如果你在函数中需要一个字符串的所有权，你可以使用第一个参数类型来避免额外的字符串拷贝。如果你想让调用者利用拥有的字符串被分配和返回的情况，第二个返回类型为 Cow 的函数可能是一个好选择。相反，我想让你从中得到的是，你应该仔细考虑你的接口对你的约束是什么契约，因为事后改变它可能是破坏性的。

在本节的其余部分，我将举例说明经常出现的接口设计决定，以及它们对你的接口契约的影响。

### 泛型参数

你的接口必须对用户提出的一个明显的要求是他们必须向你的代码提供什么类型。如果你的函数明确地接受一个 `Foo`，用户必须拥有并给你一个 `Foo`。这是没办法的事。在大多数情况下，使用泛型而不是具体类型是值得的，这样可以让调用者传递任何符合你的函数实际需要的类型，而不是只传递一种特定的类型。将清单 3-1 中的 `&str` 改为 `AsRef<str>` 是这种放松的一个例子。以这种方式放宽要求的一个方法是，从参数的完全泛型开始，不设约束，然后根据编译器的错误来发现你需要添加什么约束。

然而，如果走到极端，这种方法将使每个函数的每个参数都成为自己的泛型，这将是既难读又难理解的。对于何时应该或不应该使一个给定的参数成为泛型，并没有硬性规定，所以请使用你的最佳判断。一个好的经验法则是，如果你能想到用户可能合理地、经常地想要使用的其他类型，而不是你开始使用的具体类型，就把参数变成泛型。

你可能还记得第 2 章，泛型代码通过单态化，对曾经使用过的每一种类型的组合都是重复的。考虑到这一点，使大量参数泛化的想法可能会让你担心过度扩大你的二进制文件。在第 2 章中，我们也讨论了如何使用动态调度来缓解这种情况，其性能代价（通常）可以忽略不计，这在这里也适用。对于那些你无论如何都要通过引用来获取的参数（记得 `dyn Trait` 不是 `Sized`，你需要一个宽指针来使用它们），你可以很容易地用一个使用动态调度的参数来替换你的通用参数。例如，你可以用 `&dyn AsRef<str>` 来代替 `impl AsRef<str>`。

不过，在你跑去做这件事之前，有几件事情你应该考虑。首先，你是代表你的用户做出这个选择的，他们不能选择不使用动态调度。如果你知道你要应用动态调度的代码永远不会对性能敏感，这可能是好的。但如果有用户想在他们的高性能应用中使用你的库，那么在热循环中调用的函数中的动态调度可能会成为一个问题。其次，在写这篇文章的时候，只有当你有一个简单的特质约束时，使用动态调度才能发挥作用，比如 `T:AsRef<str>` 或 `impl AsRef<str>`。对于更复杂的约束，Rust 不知道如何构造动态调度 `vtable`，所以你不能采取，比如说，`&dyn Hash + Eq`。最后，请记住，对于泛型，调用者总是可以通过传入一个 trait 对象来选择动态调度。反之则不然：如果你带了一个特质对象，那就是调用者必须提供的。

我们可能很想从具体的类型开始你的接口，然后随着时间的推移把它们变成泛型。要知道为什么，想象一下你把一个函数从 `fn foo(v: &Vec<usize>)` 改为 `fn foo(v: impl AsRef<[usize]>)` 。虽然每个 `&Vec<usize>` 都实现了 `AsRef<[usize]>`，但类型推理仍然会给用户带来问题。考虑一下如果调用者用 `foo(&iter.collect())` 来调用 `foo` 会发生什么。在最初的版本中，编译器可以确定它应该收集到一个 `Vec`，但现在它只知道它需要收集到某个实现 `AsRef<[usize]>` 的类型。而且可能有多个这样的类型，所以有了这个改变，调用者的代码就不会再被编译了！
