# 第二章 类型

现在基础知识已经讲完了，我们来看看 Rust 的类型系统。我们将跳过《Rust 编程语言》中涉及的基础知识，转而深入研究不同类型在内存中的布局、特征和特征限定的来龙去脉、存在性类型以及跨箱体边界使用类型的规则。

## 内存中的类型

每个 Rust 值都有一个类型。在 Rust 中，类型有很多作用，我们将在本章中看到，但它们最基本的作用之一是告诉你如何解释内存的位。例如，`0b10111101`（用十六进制符号写成 0xBD）的比特序列本身并不意味着什么，直到你给它指定一个类型。 当解释为 `u8` 类型时，这个比特序列就是数字 `189`。当在 `i8` 类型下解释时，它是`-67`。当你定义自己的类型时，编译器的工作是确定定义类型的每个部分在该类型的内存表示中的位置。你的结构体的每个字段在比特序列中出现在哪里？你的枚举的判别式存储在哪里？当你开始编写更高级的 Rust 代码时，了解这个过程是很重要的，因为这些细节会影响你的代码的正确性和性能。

### 对齐

在我们讨论如何确定一个类型的内存表示之前，我们首先需要讨论对齐的概念，它决定了一个类型的字节可以存储在哪里。一旦一个类型的表示被确定，你可能会认为你可以在任何一个任意的内存位置，把存储在那里的字节解释为该类型。虽然在理论上是这样的，但在实践中，硬件也限制了一个特定类型的位置。这方面最明显的例子是，指针指向字节 (bytes)，而不是比特 (bits)。如果你把一个 `T` 类型的值放在计算机内存的第 4 位开始，你将没有办法参考它的位置；你可以创建一个指针，只指向字节 0 或字节 1（第 8 位）。由于这个原因，所有的值，无论其类型如何，都必须从一个字节边界开始。我们说，所有的值都必须至少是字节对齐的--它们必须被放在一个 8 位 (bits) 的倍数的地址上。

有些数值有更严格的对齐规则，而不仅仅是按字节对齐。在 CPU 和内存系统中，内存经常以大于一个字节的块进行访问。例如，在一个 64 位的 CPU 上，大多数数值都是以 8 个字节（64 位）为单位进行访问的，每个操作都是从一个 8 字节对齐的地址开始。这被称为 CPU 的字大小。然后，CPU 使用一些聪明的方法来处理较小的值，或跨越这些块边界的值的读写。

在可能的情况下，你要确保硬件能够以其 "原生" 对齐方式运行。要知道为什么，考虑一下如果你试图读取一个从 8 字节块中间开始的 `i64`（也就是说，它的指针不是 8 字节对齐的）会发生什么。硬件将不得不进行两次读取--一次是从第一块的后半部分读取 `i64` 的开始，另一次是从第二块的前半部分读取 `i64` 的其余部分，然后将结果拼接在一起。这不是很有效率。由于该操作分散在对底层内存的多次访问中，如果你正在读取的内存被不同的线程同时写入，你也可能会得到奇怪的结果。你可能会在其他线程的写操作发生之前读到前 4 个字节，而在之后读到后 4 个字节，从而导致一个损坏的值。

对未对齐的数据进行的操作被称为错位访问，会导致糟糕的性能和糟糕的并发性问题。出于这个原因，许多 CPU 操作要求或强烈希望其参数是自然对齐的。一个自然对齐的值是指其对齐方式与它的大小相匹配。因此，例如，对于一个 8 字节的负载，提供的地址需要 8 字节对齐。

由于对齐的访问通常更快，并提供更强的一致性语义，编译器试图尽可能地利用它们。它通过给每个类型一个基于它所包含的类型计算出来的对齐方式来实现这一点。内置值通常是根据其大小来对齐的，所以 `u8` 是字节对齐的，`u16` 是 2 字节对齐的，`u32` 是 4 字节对齐的，`u64` 是 8 字节对齐的。复杂类型--包含其他类型的类型--通常被分配为它们所包含的任何类型的最大对齐方式。例如，一个包含 `u8`、`u16` 和 `u32` 的类型会因为 `u32` 而被 4 字节对齐。

### 布局

既然您了解了对齐，我们就可以研究编译器如何决定类型的内存表示，即布局。默认情况下，您很快就会看到，Rust 编译器对如何布局类型提供了很少的保证，这是理解基本原理的一个很差的起点。幸运的是，Rust 提供了一个 `repr` 属性，您可以将其添加到类型定义中，以请求该类型在内存中的特定表示。最常见的是 `repr(C)`。顾名思义，它布局类型的方式与 C 或 C++ 编译器布局相同类型的方式兼容。这对于编写使用外部函数接口（我们将在第 11 章中讨论）与其他语言进行接口的 Rust 代码很有帮助，因为 Rust 将生成与其他语言编译器的期望相匹配的布局。由于 C 布局是可预测的，不受更改的影响，因此 `repr(C)` 在不安全的上下文中也很有用，如果您正在使用到类型的原始指针，或者您需要在两个具有相同字段的不同类型之间进行强制转换。当然，这对于我们开始布局算法的第一步来说是完美的。

> 注意：另一个有用的表示是 repr(transparent)，它只能用于具有单个字段的类型，它保证了外部类型的布局与内部类型的布局完全相同。这在与 newtype 模式结合使用时很方便，在 newtype 模式中，您可能想对某个结构 A 和结构 NewA(A) 的内存表示进行操作，就好像它们是相同的一样。如果没有 repr(transparent)，Rust 编译器就不能保证它们拥有相同的布局。

那么，让我们看看编译器会如何用 `repr(C)` 来布局一个特定的类型：清单 2-1 中的 `Foo` 类型。你认为编译器会如何在内存中布局这个类型？

```rust
#[repr(C)]
struct Foo {
    tiny: bool,
    normal: u32,
    small: u8,
    long: u64,
    short: u16,
}

// 清单 2-1: 对齐影响布局。
```

首先，编译器会看到 `tiny` 字段，它的逻辑大小是 1 位 (true 或 false)。但由于 CPU 和内存以字节为单位进行操作，因此在内存表示中，`tiny` 是 1 个字节。接下来，`normal` 是一个 4 字节类型，所以我们希望它是 4 字节对齐的。但是即使 `Foo` 是对齐的，我们分配给 `tiny` 的 1 个字节将会使 `normal` 错过它的对齐。为了纠正这个问题，编译器插入 3 个字节的填充字节，这些字节的不确定值在用户代码中被忽略，并插入到内存中 `tiny` 和 `normal` 之间的表示中。没有值进入填充，但它确实占用空间。

对于下一个字段 `small`，对齐方式很简单：它是一个 1 字节的值，当前在结构中的字节偏移量是 1+3+4=8。 这已经是字节对齐的，所以 `small` 可以紧随普通字段。但对于 `long`，我们又遇到了一个问题。我们现在是 1+3+4+1=9 字节进入 `Foo`。如果 `Foo` 是对齐的，那么 `long` 就不是我们想要的 8 字节对齐，所以我们必须再插入 7 字节的填充来使 `long` 再次对齐。这也方便了我们确保最后一个字段 `short` 所需的 2 字节对齐，使总数达到 26 字节。现在我们已经浏览了所有的字段，我们还需要确定 `Foo` 本身的对齐方式。这里的规则是使用 `Foo` 任何一个字段的最大对齐方式，由于 `long` 的原因，它将是 8 字节。因此，为了确保 `Foo` 在放入数组时保持对齐，编译器添加了最后 6 个字节的填充，使 `Foo` 的大小是其 32 字节对齐的倍数。

现在我们准备摆脱 C 语言的传统，考虑一下如果我们不使用清单 2-1 中的 `repr(C)`，布局会发生什么变化。C 表示法的主要限制之一是它要求我们以原始结构定义中的相同顺序放置所有字段。默认的 Rust 表示法 `repr(Rust)` 消除了这一限制，以及其他一些较小的限制，例如对碰巧有相同字段的类型进行确定的字段排序。也就是说，在使用默认的 Rust 布局时，即使两个不同的类型共享所有相同的字段、相同的类型、相同的顺序，也不能保证它们的布局是一样的。

由于我们现在可以对字段进行重新排序，我们可以按照大小递减的顺序来放置它们。这意味着我们不再需要 `Foo` 字段之间的填充；字段本身被用来实现必要的对齐！`Foo` 现在只是其字段的大小：只有 16 个字节。这就是为什么 Rust 默认情况下不对一个类型在内存中的布局做很多保证的原因之一：通过给编译器更多的余地来重新排列，我们可以产生更有效的代码。

事实证明，还有第三种方法来布局一个类型，那就是告诉编译器，我们不希望在字段之间有任何填充。这样做，我们就表示我们愿意接受使用错位访问的性能冲击。最常见的使用情况是，当每一个额外的字节的内存的影响是可以感觉到的，比如你有很多类型的实例，如果你有非常有限的内存，或者如果你通过一个低带宽的媒介（如网络连接）发送内存中的表示。为了选择这种行为，你可以用 `#[repr(packed)]` 来注释你的类型。请记住，这可能会导致更慢的代码，在极端情况下，如果你试图执行 CPU 只支持对齐参数的操作，这可能会导致你的程序崩溃。

有时，你想给一个特定的字段或类型一个比它技术上要求的更大的对齐方式。你可以使用属性 `#[repr(align(n))]` 来做到这一点。这方面的一个常见的用例是确保在内存中连续存储的不同数值（比如在一个数组中）最终出现在 CPU 的不同缓存行中。这样，你就可以避免错误的共享，因为错误的共享会导致并发程序的巨大性能下降。当两个不同的 CPU 访问不同的值，而这些值恰好共享一个缓存线时，就会发生虚假共享；虽然理论上它们可以并行操作，但它们最终都会争相更新缓存中的同一个条目。我们将在第 10 章中更详细地讨论并发性问题。

### 复合类型

你可能对编译器如何在内存中表示其他 Rust 类型感到好奇。这里有一个快速参考：

**元组** 表示为与元组值相同类型的字段，顺序相同。
**数组** 表示为所含类型的连续序列，元素之间没有填充物。 
**联合** 布局是为每个变体独立选择的。 对齐是所有变体的最大值。 
**枚举** 与联合相同，但有一个额外的隐藏共享字段，存储枚举变体判别符。判别值是代码用来确定一个给定值持有哪一个枚举变体的值。判别字段的大小取决于变体的数量。

### 动态大小的类型和宽指针

你可能在 Rust 文档的各种奇怪的角落和错误信息中遇到过 `Sized` 这个标记性特征。通常情况下，它的出现是因为编译器希望你提供一个 `Sized` 的类型，但你（显然）没有。Rust 中的大多数类型都自动实现了 `Sized`，也就是说，它们有一个在编译时就知道的大小，但有两种常见的类型却没有：Trait 对象和切片 (slices)。例如，如果你有一个 `dyn Iterator` 或者一个 `[u8]`，这些都没有一个明确的大小。它们的大小取决于一些只有在程序运行时才知道的信息，而不是在编译时，这就是为什么它们被称为动态大小的类型（DSTs）。没有人提前知道你的函数收到的 `dyn Iterator` 是这个 200 字节的结构还是那个 8 字节的结构。这就出现了一个问题：编译器往往必须知道某样东西的大小，以便产生有效的代码，例如为一个类型为（`i32`,`dyn Iterator`, `[u8]`, `i32`）的元组分配多少空间，或者如果你的代码试图访问第四个字段，应该使用什么偏移。但是如果类型不是 `Sized`，这些信息就无法使用。

编译器几乎在任何地方都要求类型是大小适中的。结构字段、函数参数、返回值、变量类型和数组类型都必须是 `Sized` 的。这个限制是如此的普遍，以至于你写的每一个类型绑定都包括`T：Sized`，除非你明确地用 `T：?Sized`（? 的意思是 "可能不是"）来选择不使用它。但如果你有一个 DST 并想用它做一些事情，比如你真的想让你的函数接受一个 trait 对象或一个 slice 作为参数，这就很无助了。

弥合非固定大小类型和固定大小类型之间的差距的方法是将非固定大小类型放在宽指针（也被称为胖指针）后面。一个宽指针就像一个正常的指针，但它包括一个额外的字大小的字段，它提供了编译器需要的关于该指针的额外信息，以生成合理的代码来处理该指针。当你获取一个对 DST 的引用时，编译器会自动为你构造一个宽指针。对于一个切片，额外的信息只是切片的长度。对于 trait 对象来说，我们稍后会讨论这个问题。最重要的是，这个宽指针是有尺寸的。具体来说，它是 `usize`（目标平台上一个字的大小）的两倍：一个 `usize` 用于保存指针，一个 `usize` 用于保存 "完成 "类型所需的额外信息。

> 注：Box 和 Arc 也支持存储宽指针，这就是为什么它们都支持 `T：?Sized`。

## Trait 和 Trait 限定

特质是 Rust 类型系统的一个关键部分--它们是一种胶水，允许类型之间相互操作，尽管它们在定义时并不了解对方的情况。Rust 编程语言对如何定义和使用特质做了很好的介绍，所以我在这里就不做介绍了。取而代之的是，我们要看看 traits 的一些技术方面：它们是如何实现的，你必须遵守的限制，以及 traits 的一些更深奥的用途。

### 编译和分发

到目前为止，你可能已经在 Rust 中写了相当数量的泛型代码。你已经在类型和方法上使用了泛型类型参数，甚至可能在这里和那里使用了一些 trait 限定。但是你有没有想过，当你编译泛型代码时，它究竟会发生什么，或者当你在 `dyn Trait` 上调用一个 trait 方法时，会发生什么？

当你写一个在 `T` 上泛型的类型或函数时，你实际上是在告诉编译器为每个类型 `T` 制作一个该类型或函数的副本。当你构造一个 `Vec<i32>` 或 `HashMap<String, bool>` 时，编译器基本上是复制粘贴泛型类型和它的所有实现块，并将每个泛型参数的所有实例替换为你提供的具体类型。它制作了一个 `Vec` 类型的完整副本，每个 `T` 都被替换为 `i32`，而 `HashMap` 类型的完整副本，每个 `K` 都被替换为 `String`，每个 `V` 都被替换为 bool。

> 注意：在现实中，编译器实际上并没有进行完全的复制。它只复制你使用的部分代码，所以如果你从未在 `Vec<i32>` 上调用 `find`，`find` 的代码就不会被复制和编译。

这一点也适用于泛型函数。考虑清单 2-2 中的代码，它显示了一个泛型方法。

```rust
impl String {
    pub fn contains(&self, p: impl Pattern) -> bool {
        p.is_contained_in(self)
    }
}

// 清单 2-2：使用静态分发的泛型方法
```

这个方法的副本是为每个不同的模式类型制作的（记得 `impl Trait` 是 `<T: Trait>` 的简写）。我们需要为每个 `impl Pattern` 类型提供一个不同的函数体副本，因为我们需要知道 `is_contained_in` 函数的地址来调用它。CPU 需要被告知跳转到哪里并继续执行。对于任何给定的模式，编译器知道该地址是该模式类型实现该 trait 方法的地方的地址。但是没有一个地址可以用于任何类型，所以我们需要为每个类型准备一个副本，每个副本都有自己的地址可以跳转。 这被称为静态分发，因为对于任何给定的方法副本，我们 "分发到" 的地址是静态已知的。

> 注意：你可能已经注意到，"静态" 这个词在这里有点超载。静态通常是指任何在编译时已知的东西，或者可以被当作已知的东西来对待，因为它可以被写入静态内存，正如我们在第 1 章中讨论的。

这个从一个泛型到许多非泛型的过程被称为单态化，这也是泛型 Rust 代码通常和非泛型代码表现一样好的部分原因。 当编译器开始优化你的代码时，就好像根本没有泛型的存在一样！每个实例都被单独优化，并使用所有已知的类型。每个实例都是单独优化的，并且所有的类型都是已知的。因此，代码的效率就像直接调用传入的模式的 `is_contained_in` 方法一样，没有任何特质存在。编译器对所涉及的类型有充分的了解，如果愿意，甚至可以内联 `is_contained_in` 的实现。

单态化也是有代价的：所有这些类型的实例化都需要单独编译，如果编译器不能将它们优化掉，就会增加编译时间。每个单态化的函数也会产生自己的机器代码块，这可能会使你的程序变得更大。而且，由于泛型方法的不同实例之间不共享指令，CPU 的指令缓存也是无效的，因为它现在需要保存有效相同指令的多个副本。

> 非泛型内部函数
>
> 通常情况下，泛型方法中的大部分代码是不依赖于类型的。例如，考虑一下 `HashMap::insert` 的实现。计算所提供键的哈希值的代码取决于映射的键类型，但是遍历映射的桶以找到插入点的代码可能不需要。在这种情况下，跨单一化共享方法的非通用部分生成的机器码会更有效，并且只在实际需要的地方生成不同的副本。
>
> 在这种情况下，你可以使用一种模式，即在执行共享操作的泛型方法中声明一个非泛型的辅助函数。这样，编译器就只留下与类型相关的代码来为你复制粘贴，同时允许辅助函数被共享。
>
> 把函数变成内部函数还有一个好处，就是你不会用一个单一目的的函数来污染你的模块。你可以在方法之外声明这样一个辅助函数；只是要注意不要让它成为泛型植入块下的方法，因为那样它仍然会被单态化。

静态分发的替代方法是动态分发，它使代码能够在不知道是什么类型的情况下调用一个泛型类型的 trait 方法。我在前面说过，我们需要清单 2-2 中方法的多个实例的原因是，否则你的程序就不知道要跳转到什么地址，以便在给定的模式上调用特征方法 `is_contained_in`。那么，通过动态分发，调用者会简单地告诉你。如果你用 `&dyn Pattern` 代替 `impl Pattern`，你就告诉调用者他们必须为这个参数提供两个信息：模式的地址和 `is_contained_in` 方法的地址。实际上，调用者给了我们一个指针，指向一个叫做虚拟方法表（vtable）的内存块，这个虚拟方法表保存了有关类型的所有 trait 方法的实现地址，其中一个就是 `is_contained_in`。当方法中的代码想要调用所提供的模式的特质方法时，它会在 `vtable` 中查找该模式的 `is_contained_in` 的实现地址，然后调用该地址的函数。这使得我们可以使用相同的函数体，无论调用者想使用什么类型。

> 注意：每个 `vtable` 都包含了关于具体类型的布局和对齐方式的信息，因为这些信息在使用一个类型时总是需要的。如果你想看一个显式 `vtable` 的例子，看看 `std::task::RawWakerVTable` 类型。

你会注意到，当我们选择使用 `dyn` 关键字进行动态分发时，我们必须在它的前面放一个 `&`。原因是我们在编译时不再知道调用者传入的模式类型的大小，所以我们不知道要为它预留多少空间。换句话说，`dyn Trait` 是 `!Sized`，其中的 `!` 表示不。为了使它有大小，以便我们可以把它作为一个参数，我们把它放在一个指针（我们知道它的大小）后面。由于我们还需要传递方法地址表，这个指针变成了一个广义的指针，其中额外的字是指向 `vtable` 的指针。你可以使用任何能够容纳宽指针的类型进行动态分发，比如 `&mut`、 `Box` 和 `Arc`。清单 2-3 显示了清单 2-2 的动态分发等价物。

```rust
impl String {
    pub fn contains(&self, p: &dyn Pattern) -> bool {
        p.is_contained_in(&*self)
    }
}

// 清单 2-3: 使用动态分发的泛型方法
```

实现特质的类型和其 `vtable` 的组合被称为特质对象。大多数特质可以变成特质对象，但不是全部。例如，`Clone trait`，其 `clone` 方法返回 自身，不能被转化为特质对象。如果我们接受一个 `dyn Clone trait` 对象，然后对它调用 `clone`，编译器将不知道要返回什么类型。或者，考虑一下标准库中的 `Extend trait`，它有一个方法 `extend`，在所提供的迭代器的类型上是通用的（所以它可能有很多实例）。如果你要调用一个接受动态 `Extend` 的方法，那么就没有一个单一的地址可以放在 trait 对象的 `vtable` 中；对于 `extend` 可能被调用的每种类型，都必须有一个条目。这些都是特性的例子，它们不是对象安全的，因此不能被变成特性对象。为了实现对象安全，特质的任何方法都不能是泛型的或使用`Self` 类型。此外，特质不能有任何静态方法（也就是说，其第一个参数不解引用到 `Self`），因为不可能知道要调用哪个方法的实例。例如，不清楚 `FromIterator::from_iter(&[0])` 应该执行什么代码。

在阅读关于特质对象的文章时，你可能会看到提到特质绑定 `Self: Sized`。这样的约束意味着 `Self` 不会通过 trait 对象被使用（因为它将是 `!Sized`）。你可以把这个约束放在特质上，要求特质永远不使用动态分发，或者你可以把它放在一个特定的方法上，使该方法在通过特质对象访问特质时不可用。当检查一个特质是否是对象安全的时候，具有 `where Self: Sized` 绑定的方法被豁免。

动态分发可以缩短编译时间，因为它不再需要编译多个类型和方法的副本，而且可以提高 CPU 指令缓存的效率。然而，它也阻止了编译器对所使用的特定类型进行优化。有了动态分发，编译器对清单 2-2 中的 `find` 所能做的就是通过 `vtable` 插入对函数的调用--它不能再执行任何额外的优化，因为它不知道在这个函数调用的另一边会有什么代码。 此外，对 trait 对象的每个方法调用都需要在 `vtable` 中进行查找，这比直接调用方法增加了少量的开销。

当你要在静态分发和动态分发之间做出选择时，很少有明确的正确答案。不过，广义上讲，你想在你的库中使用静态分发，在你的二进制文件中使用动态分发。在库中，你想让你的用户来决定哪种分发最适合他们，因为你不知道他们的需求是什么。如果你使用动态分发，他们也会被迫这样做，而如果你使用静态分发，他们可以选择是否使用动态分发。另一方面，在二进制文件中，你正在编写最终的代码，所以除了你正在编写的代码的需求外，没有其他需求需要考虑。 动态分发通常允许你编写更干净的代码，省去泛型参数，并能更快地编译，所有这些都是以（通常）边际性能为代价，所以它通常是二进制文件的更好选择。

### 泛型 Traits
