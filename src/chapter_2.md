#  第二章 类型

现在基础知识已经讲完了，我们来看看 Rust 的类型系统。我们将跳过《Rust 编程语言》中涉及的基础知识，转而深入研究不同类型在内存中的布局、特征和特征限定的来龙去脉、存在性类型以及跨箱体边界使用类型的规则。

## 内存中的类型

每个 Rust 值都有一个类型。在 Rust 中，类型有很多作用，我们将在本章中看到，但它们最基本的作用之一是告诉你如何解释内存的位。例如，`0b10111101`（用十六进制符号写成 0xBD）的比特序列本身并不意味着什么，直到你给它指定一个类型。 当解释为 `u8` 类型时，这个比特序列就是数字 `189`。当在 `i8` 类型下解释时，它是`-67`。当你定义自己的类型时，编译器的工作是确定定义类型的每个部分在该类型的内存表示中的位置。你的结构体的每个字段在比特序列中出现在哪里？你的枚举的判别式存储在哪里？当你开始编写更高级的 Rust 代码时，了解这个过程是很重要的，因为这些细节会影响你的代码的正确性和性能。

### 对齐

在我们讨论如何确定一个类型的内存表示之前，我们首先需要讨论对齐的概念，它决定了一个类型的字节可以存储在哪里。一旦一个类型的表示被确定，你可能会认为你可以在任何一个任意的内存位置，把存储在那里的字节解释为该类型。虽然在理论上是这样的，但在实践中，硬件也限制了一个特定类型的位置。这方面最明显的例子是，指针指向字节(bytes)，而不是比特(bits)。如果你把一个 `T` 类型的值放在计算机内存的第 4 位开始，你将没有办法参考它的位置；你可以创建一个指针，只指向字节 0 或字节 1（第 8 位）。由于这个原因，所有的值，无论其类型如何，都必须从一个字节边界开始。我们说，所有的值都必须至少是字节对齐的--它们必须被放在一个 8 位的倍数的地址上。
